
const fs = require('fs')
const path = require('path')


let runnerModeFullscreen = false

/**
 * Since the viewport size is now not guaranteed to be the config viewport size, 
 * this function can be used as a substitute for Cypress.config().viewportWidth
 * @returns {number} The width of the viewport
 */
function viewportWidth() {
    if (runnerModeFullscreen) {
        return 1280
    } else {
        return Cypress.config().viewportWidth
    }
}

/**
 * Since the viewport size is now not guaranteed to be the config viewport size, 
 * this function can be used as a substitute for Cypress.config().viewportHeight
 * @returns {number} The height of the viewport
 */
function viewportHeight() {
    if (runnerModeFullscreen) {
        return 720
    } else {
        return Cypress.config().viewportHeight
    }
}


/**
 * For internal use of the hideCypress command.
 * Lets you manually configure whether the runner is fullscreen / cypress UI are hidden
 * Not testable.
 * @param {boolean} fullscreen - Whether or not the viewport of the runner is fullscreen (i.e. cypress elements hidden), or it's in normal testing mode
 */
function setRunnerMode(fullscreen) {
    runnerModeFullscreen = fullscreen
}


/**
 * Converts a number to the HTML/CSS notation for pixel distances
 * @param {number} a - Amount of pixels.
 * @returns {string} String pixel notation.
 */
function intToPx(a) {
    return a.toString() + 'px'
}

/**
 * Converts a number alpha value to HTML hex code to be used in color codes.
 * @param {number} a - Alpha value
 * @returns {string} Hex code representation
 */
function alphaToHtml(a) {
    return Math.round(a*255).toString(16).padStart(2, '0')
}

/**
 * Returns whether this class exists within the DOM.
 * @param {string} c - Class name (without '.' in front)
 * @returns {boolean} The existence of the class in the website DOM
 */
function classExists(c) {
    return cy.state('document').querySelectorAll('.' + c).length > 0
}


/**
 * Returns the highest z-index currently on the web page.
 * @returns {number} Highest z-index on web page.
 */
function getHighestZIndex() {
    const doc = cy.state('document')
    // Code generously tutorialed (and further expanded on!!) from https://bobbyhadz.com/blog/javascript-find-highest-z-index-on-page
    return Math.max(
                ...Array.from(doc.querySelectorAll("body *"),
                    (element) => {
                        if (!element.hasAttribute('data-stay-on-top')) {
                            return parseFloat(window.getComputedStyle(element).zIndex)
                        } else {
                            return null
                        }
                    }
                ).filter(
                    zIndex => !Number.isNaN(zIndex)
                ),
            0)
}


/**
 * Returns the next z-index for an element to be created at in order to be on top of the web page.
 * @param {number} notify - Notify the getNextZIndex function that this z-index value will be added to the page. Only necessary to use when also setting custom z-index
 * @returns {number} Highest existing z-index + 1.
 */
function getNextZIndex(notify = 0) {
    // We take a very high z-index here because of a couple of reasons:
    // 1. If a website creates an element with a z-index after loading, we want most websites to not create that element over our elements.
    // 2. 99% of websites will not use this high of a z-index, in the case of 1.
    // But if a website also calculates the highest z-index to create a new element, I don't think we have a workaround for that :<
    const minVideoZ = 100000
    const next = Math.max(getHighestZIndex() + 1, minVideoZ, notify)
    keepOnTop(next)
    return next
}


/**
 * Keeps all elements that are labeled to stay on top, on the top, z-index wise.
 * @param {number} highest - The highest (pending) z-index in the DOM.
 */
function keepOnTop(highest) {
    // Get all elements that need to stay on top
    const doc = cy.state('document')
    const allStayOnTop = [...doc.querySelectorAll('[data-stay-on-top]')]
    const z = highest + 2 // +2 instead of +1, since when getNextZIndex is called, the element that requested it might not yet actually be added to the DOM

    // Keep those elements on top
    allStayOnTop.forEach(element => {
        element.style.zIndex = z
    })
}


/**
 * Converts an amount of seconds to a hh:mm:ss.ms format.
 * @param {number} s - Time in seconds.
 * @returns {string} The seconds converted to hh:mm:ss.ms format.
 */
function msToTime(s) {
    var ms = s % 1000;
    s = (s - ms) / 1000;
    var secs = s % 60;
    s = (s - secs) / 60;
    var mins = s % 60;
    var hrs = (s - mins) / 60;

    return hrs + ':' + mins + ':' + secs  + '.' + (Math.round(ms) + "").padStart(3, '0');
}

/**
 * Adds an element to the website 'body'. 
 * The element seen as the body can be changed throughout a run, so this function ensures the right body is used.
 * @param {Document} document - The document of the website.
 * @param {Element} element - The element to be added.
 */
function addToBody(document, element){
    var newBody = document.querySelector("#NewBody")
    if (newBody && element.style.position !== 'fixed'){
        newBody.appendChild(element)
    } else {
        document.body.appendChild(element)
    }
}

/**
 * Get the offset of the element without scaling for zooming.
 * @param {Element} [element] - The element to compute the offset for.
 * @returns {object} Object with the top and left of the element relative to the page
 */
function getOffset(element) {
    var x = 0;
    var y = 0;
    while (element && !isNaN(element.offsetLeft) && !isNaN(element.offsetTop)) {
        x += element.offsetLeft - element.scrollLeft
        y += element.offsetTop  - element.scrollTop
        element = element.offsetParent
    }
    return {top: y, left: x};
}

/**
 * Returns whether or not the element is a fixed element or is under a fixed ancestor.
 * @param {Document} document - The document of the website.
 * @param {Element} element - The element to be examined.
 * @returns {boolean}
 */
 function isElementUnderFixed(document, element) {
    let current = element
    while (current !== document.body) {
        const style = getComputedStyle(current)
        if (style.position == 'fixed') {
            return true
        }
        current = current.parentNode
    }

    return false
}

/**
 * Fetches the filepath of the mouse indicator image during a cypress test.
 * Not testable (fs not importable in cypress test).
 * @returns the filepath of the mouse indicator image during a cypress test.
 */
function fetchFilePath() {
    const image = path.join(__dirname, './assets/filled-pointer.svg')
    const file = fs.readFileSync(image, {encoding: 'utf8'})
    return file
}

module.exports = {
    intToPx: intToPx,
    alphaToHtml: alphaToHtml,
    classExists: classExists,
    setRunnerMode: setRunnerMode,
    viewportWidth: viewportWidth,
    viewportHeight: viewportHeight,
    msToTime: msToTime,
    getHighestZIndex: getHighestZIndex,
    getNextZIndex: getNextZIndex,
    keepOnTop: keepOnTop,
    addToBody: addToBody,
    getOffset: getOffset,
    fetchFilePath: fetchFilePath,
    isElementUnderFixed:isElementUnderFixed
}