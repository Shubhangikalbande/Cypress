import {viewportHeight, viewportWidth, getOffset, isElementUnderFixed} from '../utility.js'
import { checkParameter, isPositive, isNonNegative } from '../errors.js'

/**
 * Dual Command.
 * If used as a parent command, it zooms the screen in on the given coordinates
 * If used as a child command, it zooms in on the subject DOM element(The first one given).
 * @param {Cypress.Chainable} subject - Supplied by Cypress. Not needed to use this parameter.
 * @param {number} zoomFactor - The amount that will be zoomed in. A factor of 2 will take a 4th of the screen.
 * @param {number} [x] - If called as a parent command, the x-coordinate of the point that will be zoomed into.
 *                    If called as a child command, the offset on the x axis relative to the center of the subject.
 * @param {number} [y] - If called as a parent command, the y-coordinate of the point that will be zoomed into.
 *                    If called as a child command, the offset on the y axis relative to the center of the subject.
 * @param {number} [duration] - The duration of the zoom animation in milliseconds if present.
 * @param {string} [easing] - The style of the zoom animation if present.
 * @param {boolean} [limitElementZoom] - Whether the subject should remain visible in its entirety.
 * @param {boolean} [firstScroll] - Whether the function should scroll to the passed coordinates before zooming in.
 */
 function addZoom(subject, zoomFactor, {
    x = 0,
    y = 0,
    duration = 1000,
    easing = 'ease',
    limitElementZoom = true,
    firstScroll = true
}={}) {
    Cypress.log({displayName: "addZoom"})
    
    const document = cy.state('document')
    const win = cy.state('window')

    if (Cypress.env("CY_VIDEO_MODE") != true) {
        return
    }

    checkParameter(zoomFactor, isPositive, 'zoomFactor', 'addZoom')
    checkParameter(duration, isNonNegative, 'duration', 'addZoom')
    checkParameter(easing, {
        message: "is an easing animation (can be one of 'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out')", 
        function: (e) => ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out'].includes(e)
        }, 'easing', 'addZoom')

    // When zooming in on fixed elements. This is not the desired behaviour!
    // For website fixed elements (fixed through a class) we translate them to an
    // absolute position at the same position of the original. This causes the
    // elements to seemingly stay the same and enables zooming in on them.
    // For CVC fixed elements like addText, we don't zoom in at all, as we want
    // these element to actually stay fixed. This is why we make a NewBody:
    // so we have a div we can zoom into without zooming in to CVC elements.
    // If in the future the NewBody messes with a website, it might be worth
    // trying to put all the CVC elements next to the website pagebody and
    // not using a newBody.

    // Check if the NewBody already exists
    // Else, create it and add it to the body
    var zoomParentDiv = document.querySelector("#NewBody")
    if ( !zoomParentDiv ) {
        zoomParentDiv = document.createElement('div')
        zoomParentDiv.id = "NewBody"
        document.body.appendChild(zoomParentDiv)
    }

    // If there is an subject, get it's coordinates.
    if (subject){

        // Get subject coordinates and apply offset
        x = getOffset(subject[0]).left + subject[0].offsetWidth/2 + x
        y = getOffset(subject[0]).top + subject[0].offsetHeight/2 + y

        if (isElementUnderFixed(document, subject[0])) {
            y += win.scrollY
        }

        if (limitElementZoom) {
            // Make sure subject isn't cut off by the zooming
            let subjectScaleWidth = viewportWidth() / subject[0].offsetWidth
            let subjectScaleHeight = viewportHeight() / subject[0].offsetHeight

            zoomFactor = Math.max(1, Math.min(zoomFactor, subjectScaleWidth, subjectScaleHeight))
        }
    }

    // Make sure the zooming doesn't expose any whitespace outside the website
    cy.getWindowHeight(subject, document, win.scrollY).then(([windowStart, windowHeight]) => {
        x = Math.min(Math.max((viewportWidth()/zoomFactor)/2, x), viewportWidth() - (viewportWidth()/zoomFactor)/2)
        y = Math.min(Math.max(windowStart + (viewportHeight()/zoomFactor)/2, y), windowHeight - (viewportHeight()/zoomFactor)/2)

        // Decide whether the website should be scrolled before zooming
        if (firstScroll && (win.scrollY > y || y > win.scrollY+viewportHeight())){
            // Zoom out before scrolling
            const alreadyZoomed = zoomParentDiv.style.transform != "scale(1)" && zoomParentDiv.style.transform != ""
            if (alreadyZoomed){
                cy.resetZoom(1, {duration: duration, easing: easing})
            }

            // Actual scrolling
            cy.scrollTo(x, y-viewportHeight()/2, {easing:'swing', duration:Math.min(3000, Math.abs(y - win.scrollY)), log: false})
        } else {
            // limit the zooming to what is on screen if the center is on screen
            y = Math.min(Math.max(win.scrollY + (viewportHeight()/zoomFactor)/2, y), win.scrollY + viewportHeight() - (viewportHeight()/zoomFactor)/2)
        }

        // Move the website to the zoomParentDiv so the program can zoom in on the website,
        // without making cvc Elements invisible
        cy.moveWebsiteToNewBody(zoomParentDiv, document)

        // Apply offset to coordinates to account for the fact that the css zoom function only partly zooms in
        cy.setTransformOriginCorrectly(zoomParentDiv, x, y, zoomFactor)

        // This waiting is needed for some reason to avoid a strange animation
        cy.wait(700, {log:false})
        cy.transition(zoomParentDiv, duration/1000, easing)

        // Start the async transform and wait till its finished
        cy.transform(zoomParentDiv, zoomFactor)
        cy.wait(duration, {log:false})

        // If the zoomFactor is 1 the program should clean up the NewBody div created
        // for zooming and restore the DOM to its original state
        if (zoomFactor == 1) {
            cy.moveWebsiteFromNewBody(zoomParentDiv, document)
        }
    })
}


/**
 * Parent command
 * @param {float} [duration] - The duration of the zoom animation if present
 * @param {string} [easing] - The style of the zoom animation if present
 */
function resetZoom({
    duration = 1000,
    easing = 'ease'
} = {}) {
    Cypress.log({displayName: "resetZoom"})

    checkParameter(duration, isNonNegative, 'duration', 'addZoom')
    checkParameter(easing, {
        message: "is an easing animation (can be one of 'linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out')", 
        function: (e) => ['linear', 'ease', 'ease-in', 'ease-out', 'ease-in-out'].includes(e)
        }, 'easing', 'addZoom')


    const document = cy.state('document')

    // See comment about NewBody in the zoom function
    var zoomParentDiv = document.querySelector("#NewBody")
    if ( !zoomParentDiv ) {
        // If there is no NewBody element, we weren't zoomed in
        return
    }

    cy.transition(zoomParentDiv, duration/1000, easing)

    // Start the async transform and wait till its finished
    cy.transform(zoomParentDiv, 1)
    cy.wait(duration, {log:false})

    // Clean up the NewBody div
    cy.moveWebsiteFromNewBody(zoomParentDiv, document)
}

/**
 * Returns the lowest and highest y position that may be on screen after zooming.
 * If the element being zoomed in on is fixed this limited to what is currently on screen.
 * Otherwise the whole page is allowed.
 * @param {Cypress.Chainable} element - The element being zoomed in on
 * @param {Document} document - The document of the website.
 * @param {number} scrollY - The amount the page is scrolled down.
 * @returns {array} The lowest and highest y position that may be on screen after zooming.
 */
Cypress.Commands.add('getWindowHeight', (element, document, scrollY) => {
    if (element && isElementUnderFixed(document, element[0])) {
        return [scrollY, scrollY + viewportHeight()]
    } else {
        return [0, document.documentElement.scrollHeight]
    }
})

/**
 * Moves all website elements from NewBody to document.body
 * @param {HTML object} [zoomParentDiv] the NewBody element
 * @param {HTML object} [document] the document element
 */
Cypress.Commands.add('moveWebsiteFromNewBody', (zoomParentDiv, document) => {
    const win = cy.state('window');
    [...zoomParentDiv.children].forEach(c => {
        c.classList.remove("cypress-video-creator-fade-in")
        c.classList.remove("cypress-video-creator-fade-out")
        c.classList.remove("cypress-video-creator-expand")
        c.classList.remove("cypress-video-creator-shrink")
        if (c.style.positon !== 'fixed' && c.id != "NewBody") {
            if (c.classList.contains("cypress-video-was-fixed-to-bottom") || c.classList.contains("cypress-video-was-fixed-to-top")) {
                const style = getComputedStyle(c)
                c.style.position = "fixed"
                if (c.classList.contains("cypress-video-was-fixed-to-bottom"))
                    c.style.bottom = parseFloat(style.bottom) - win.scrollY + "px"
                else
                    c.style.top = parseFloat(style.top) - win.scrollY + "px"
            }
            document.body.appendChild(c)
        }
    })
    //while(zoomParentDiv.firstChild) zoomParentDiv.removeChild(zoomParentDiv.lastChild)
    document.body.removeChild(zoomParentDiv)

    // enable scrolling
    win.onscroll = function() {}
})

/**
 * Moves all website elements from document.body to NewBody
 * @param {HTML object} [zoomParentDiv] the NewBody element
 * @param {HTML object} [document] the document element
 */
Cypress.Commands.add('moveWebsiteToNewBody', (zoomParentDiv, document) => {
    // Add all childeren the the NewBody
    const win = cy.state('window');
    [...document.body.children].forEach(c => {
        c.classList.remove("cypress-video-creator-fade-in")
        c.classList.remove("cypress-video-creator-fade-out")
        c.classList.remove("cypress-video-creator-expand")
        c.classList.remove("cypress-video-creator-shrink")
        if (c.style.positon !== 'fixed' && c.id != "NewBody") {
            const style = getComputedStyle(c)
            if (style.position === "fixed") {
                c.style.position = "absolute"
                c.style.top = parseFloat(style.top) + win.scrollY + "px"
                // By setting height to a random value the value doesn't half disappear. WTF?
                c.style.height = "100%"
                if (c.style.bottom)
                    c.classList.add("cypress-video-was-fixed-to-bottom")
                else
                    c.classList.add("cypress-video-was-fixed-to-top")
            }
            zoomParentDiv.appendChild(c)
        }
    })

    // To fix issue where website fixed elements are in body after an iteration of zoom, we remove all from body
    // and add newbody and our fixed elements again
    const allFixed = [...document.querySelectorAll('*')].filter(el => el.style.position == 'fixed')
    while(document.body.firstChild) document.body.removeChild(document.body.lastChild)
    document.body.appendChild(zoomParentDiv)
    allFixed.forEach(f => document.body.appendChild(f))

    // disable scrolling
    const scrollLeft = win.scrollX
    const scrollTop = win.scrollY
    win.onscroll = function() {
        win.scrollTo(scrollLeft, scrollTop);
    }
})

/**
 * Changes the focus point of any scale function applied to the website
 * @param {HTML object} [div] Object containing the html code of the website that is being run by cypress
 * @param {int} [x] The x coordinate of the location that will be the point that any potential zoom wil zoom towards
 * @param {int} [y] The y coordinate of the location that will be the point that any potential zoom wil zoom towards
 * @param {number} [zoomFactor] The zoomFactor by which the website should be zoomed
 */
Cypress.Commands.add('setTransformOriginCorrectly', (div, x, y, zoomFactor) => {
    const win = cy.state('window')

    const currentx = viewportWidth() / 2
    const currenty = win.scrollY + viewportHeight() / 2

    const adjustedx = currentx + (x - currentx) * zoomFactor / (zoomFactor-1)
    const adjustedy = currenty + (y - currenty) * zoomFactor / (zoomFactor-1)

    div.style.transformOrigin = adjustedx + "px " + adjustedy + "px"
})

/**
 * Changes the transition animation of the any zooming that happens
 * @param {HTML Object} [div] Object containing the html code of the website that is being run by cypress
 * @param {float} [duration] The amount of time that will the zoom animation will take
 * @param {string} [style] The style with which the zoom is applied
 */
Cypress.Commands.add('transition', (div, duration, style) => {div.style.transition = `all ${duration}s ${style}`})

/**
 * Applies the css zoom function to the body of the html div, which will trigger the zoom
 * @param {HTML Object} [div] Object containing the html code of the website that is being run by cypress
 * @param {int} [zoomFactor] The amount of zoom that will be applied. With 2x zoom, all elements will be scaled to be
 *                           2x bigger in both axis
 */
Cypress.Commands.add('transform', (div, zoomFactor) => {div.style.transform = "scale(" + zoomFactor + ")"})

Cypress.Commands.add('addZoom', {prevSubject : 'optional'}, addZoom)
Cypress.Commands.add('resetZoom', {}, resetZoom)