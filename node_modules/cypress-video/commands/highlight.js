import {intToPx, alphaToHtml, getNextZIndex, addToBody, getOffset, isElementUnderFixed} from '../utility.js'
import {COLOR_DICT, getAnimationClass, addStyles} from './style.js'
import { checkParameter, isColorGradient, isAnimationClass, isBetweenOneAndZero, isPositive } from '../errors.js'

export const highlightClass = "cypress-video-highlight";
export const highlightElementClass = "cypress-video-element-highlight";
export const highlightContainerClass = "cypress-highlight-container";

/**
 * Dual Command.
 * If used as a parent command it highlights a rectangle on the screen.
 * If used as a child command, it highlights the subject DOM element(s).
 * @param {Cypress.Chainable} subject - Supplied by Cypress. Not needed to use this parameter.
 * @param {string|object} [color] - The color of the highlight or the colors for the gradient color of the highlight, using HTML hexadecimal colour codes (eg. `#FFD200`).
 * @param {number|string} [gradientDirection] - The direction of the gradient. Accepted values: an angle in degrees, or 'circle'.
 * @param {number} [alpha] - The opacity of the highlight.
 * @param {number} [x] - If called as a parent command, the x-coordinate of the top-left corner of the highlight.
 * @param {number} [y] - If called as a parent command, the y-coordinate of the top-left corner of the highlight.
 * @param {number} [z] - The z-index of the highlight.
 * @param {number} [width] - If called as a parent command, the width of the highlight.
 * @param {number} [height] - If called as a parent command, the height of the highlight.
 * @param {boolean} [absolute] - If called as a parent command, whether or not the rectangle is fixed to the viewport or absolutely positioned on the webpage.
 * @param {boolean} [stayOnTop] - Whether or not the highlight should stay on top of every other element, z-index wise.
 * @param {string} [entry] - The name of the entry animation. Eg. 'fade-in' or 'expand'.
 * @param {number} [wait] - The amount of time to automatically wait after adding the highlight and then removing it. Note that multitasking during this wait is **not** possible.
 * @returns {Cypress.Chainable} The cypress-wrapped highlight element that was added.
 */
function addHighlight(subject, {
    color = '#FFD200',
    gradientDirection = 180,
    alpha = 0.5,
    x = 0,
    y = 0,
    z = -1,
    width = 100,
    height = 100,
    absolute = false,
    stayOnTop = false,
    entry = null,
    wait = null
} = {}) {
    if (Cypress.env("CY_VIDEO_MODE") != true) {
        const document = cy.state('document')
        return cy.wrap(document.body, {log: false})
    }

    Cypress.log({displayName: "addHighlight"})

    //check parameters
    checkParameter(color, isColorGradient, 'color', 'addHighlight')
    checkParameter(alpha, isBetweenOneAndZero, 'alpha', 'addHighlight')
    checkParameter(z + 2, isPositive, 'z', 'addHighlight')
    checkParameter(width, isPositive, 'width', 'addHighlight')
    checkParameter(height, isPositive, 'height', 'addHighlight')
    if (entry) checkParameter(entry, isAnimationClass, 'entry', 'addHighlight')

    const document = cy.state('document')

    const hl = document.createElement('div')
    const id = Math.random().toString(36).slice(2, 7)
    hl.id = id

    // Add class to be able to query all of its kind later it later
    hl.classList.add(subject ? highlightElementClass : highlightClass)

    // General stuff
    hl.style.display = 'block'
    hl.style.pointerEvents = 'none'

    // Color and gradients
    if (typeof color == 'string') {
        hl.style.backgroundColor = (color in COLOR_DICT ? COLOR_DICT[color] : color) + alphaToHtml(alpha)
    } else {
        // Initialise the radial or linear gradient with its direction
        let gradientString = gradientDirection == 'circle' ? 'radial-gradient(' : 'linear-gradient(' + gradientDirection + 'deg, '

        // Update all the colours with the opacity
        for (let i = 0; i < color.length; i++) {
            color[i] = color[i] in COLOR_DICT ? COLOR_DICT[color[i]] : color[i]
            color[i] += alphaToHtml(alpha)
        }

        // Add all the colours to the gradient
        gradientString += color.join(', ') + ')'
        hl.style.background = gradientString
    }

    // Z-indexing
    if (stayOnTop) {
        hl.setAttribute('data-stay-on-top', '')
    } else {
        let zIndex = z
        const nextZ = getNextZIndex(z)
        zIndex = z === -1 ? nextZ : z
        hl.style.zIndex = zIndex
    }

    // Positioning
    if (subject) {
        hl.style.left = intToPx(0)
        hl.style.right = intToPx(0)
        hl.style.top = intToPx(0)
        hl.style.bottom = intToPx(0)
        hl.style.position = 'absolute'
    } else {
        hl.style.left = intToPx(x)
        hl.style.top = intToPx(y)
        hl.style.width = intToPx(width)
        hl.style.height = intToPx(height)
        hl.style.position = absolute ? 'absolute' : 'fixed'
    }

    // Highlight an element
    if (subject) {
        const elements = subject.selector ? document.querySelectorAll(subject.selector) : [subject[0]]
        Array.from(elements).forEach(element => {
            // Taking element.style.<x> will only work for the style attributes specifically given to the element itself, not its class attributes
            const style = getComputedStyle(element)
            const hlClone = hl.cloneNode()

            // Z-index stuff
            if (!stayOnTop && z === -1) {
                hlClone.style.zIndex = parseFloat(style.zIndex) + 1
            }
            
            // If the element is fixed on the page, either through itself being fixed or it being under a fixed ancestor,
            // we need to handle the highlight in a special way: basically overlaying the highlight over the element.
            if (isElementUnderFixed(document, element)) {
                hlClone.style.position = 'fixed'
                const offset = getOffset(element)
                hlClone.style.top = intToPx(offset.top)
                hlClone.style.left = intToPx(offset.left)
                hlClone.style.width = intToPx(element.offsetWidth)
                hlClone.style.height = intToPx(element.offsetHeight)

                element.parentNode.insertBefore(hlClone, element)
            // Otherwise use the same wrapper method as before
            } else {
                const type = element.tagName == 'span' ? 'span' : 'div'
                const wrapper = document.createElement(type)
                wrapper.classList.add(highlightContainerClass)

                // Make sure the wrapper takes the dimensions of the original element, 
                // such that the element will be in the same spot AND the highlight will be over the element
                wrapper.style.left = style.left
                wrapper.style.right = style.right
                wrapper.style.top = style.top
                wrapper.style.bottom = style.bottom
                wrapper.style.position = 'relative' // This might have to be changed for absolute elements
                
                // Wrap the wrapper around the element and also make the element just sit in the top-left corner of the wrapper,
                // because the wrapper copies the positioning from the element, and thus otherwise the element would have its offsets done twice.
                element.parentNode.insertBefore(wrapper, element)
                element.style.position = ['relative', 'absolute'].includes(style.position) ? 'static' : style.position
                wrapper.appendChild(element)
                wrapper.appendChild(hlClone)
            }
        });
    // Otherwise just add the highlight to the body
    } else {
        addToBody(document, hl)
    }

    // Notify Utility for the potential stayOnTop enjoyers
    getNextZIndex(z)

    // Add animations
    if (entry) {
        addStyles()
        const highlights = document.querySelectorAll('[id=\''+ id + '\']')
        Array.from(highlights).forEach((highlight) => {
            highlight.classList.add(getAnimationClass(entry))
        })

        cy.wait(1000, {log: false})
    }

    // Automatic wait and removal
    if (wait) {
        cy.get('[id=\'' + id + '\']', {log: false}).wait(wait).remove() // We do want this one to be logged, because it's supposed to be a normal wait.
        return cy.wrap(null, {log: false})
    }

    return cy.get('[id=\'' + id + '\']', {log: false})
}

Cypress.Commands.add('addHighlight', {prevSubject : 'optional'}, addHighlight)

