import {intToPx, alphaToHtml, getNextZIndex, addToBody, getOffset} from '../utility.js'
import {COLOR_DICT, addStyles, getAnimationClass} from './style.js'
import { checkParameter, isHexColor, isAnimationClass, isPositive, isBetweenOneAndZero, isNonNegative } from '../errors.js'

export const imageClass = 'cypress-video-image'

/**
 * Add text at the given position
 * @param {Cypress.Chainable} subject - Supplied by Cypress. Not needed to use this parameter.
 * @param {string} source - The source of the image, the image that will be shown.
 * @param {string} [pos] - The position of the image relative to an element. Accepted values are: on_top, above, below, left and right.
 * @param {number} [x] - The x-coordinate where the image should start.
 * @param {number} [y] - The y-coordinate where the image should start. 
 * @param {number} [z] - The z-index of the image.
 * @param {number} [width] - Stretch the image to be this width. The default width is the image width scaled to the height.
 * @param {number} [height] - Stretch the image to be this height. The default height is the image height scaled to the width.
 * @param {boolean} [resize] - Whether the image should be resized when the width and height do not equal the image's width and height
 * @param {Array[number]} [top_left] - The top-left coordinate of the image. This parameter is used to crop the image
 * @param {object|number} [scale] - The scale of the image, first int of the object is the scale applied to the width and the second is the scale applied to the height. If the scale is an int, the scale is applied to both the width and height
 * @param {number} [opacity] - The opacity of the image.
 * @param {number} [rotate] - The rotation of the image in degrees.
 * @param {number} [contrast] - The contrast of the image.
 * @param {number} [saturate] - The saturation of the image.
 * @param {string} [bg_color] - The color of the background area, using HTML hexadecimal colour codes (eg. #FFD200).
 * @param {number} [bg_alpha] - The opacity of the background area.
 * @param {boolean} [absolute] - Whether the rectangle is fixed to the viewport or absolutely positioned on the webpage.
 * @param {string} [entry] - The name of the entry animation. Eg. 'fade-in' or 'expand'.
 * @param {boolean} [stayOnTop] - Whether or not the image should stay on top of every other element, z-index wise.
 * @param {number} [wait] - The amount of time to automatically wait after adding the image and then removing it. Note that multitasking during this wait is **not** possible.
 * @returns {Cypress.Chainable} The cypress-wrapped image element that was added.
 */
function addImage(subject, source = "", {
    pos = 'on_top',
    x = 0,
    y = 0,
    z = -1,
    width = null,
    height = null,
    resize = true,
    top_left = [0, 0],
    scale = [1, 1],
    opacity = 1,
    rotate = 0,
    contrast = 1,
    saturate = 1,
    bg_color = null,
    bg_alpha = 1,
    absolute = true,
    entry = null,
    stayOnTop = false,
    wait = null
}={}) {
    if (!Cypress.env("CY_VIDEO_MODE")) {
        const document = cy.state('document')
        return cy.wrap(document.body, {log: false})
    }

    Cypress.log()

    // Parameter checking
    if (width) checkParameter(width, isPositive, 'width', 'addImage')
    if (height) checkParameter(height, isPositive, 'height', 'addImage')
    checkParameter(top_left, {message: "is an array containing two elements" ,function: (tl) => Array.isArray(tl) && tl.length == 2}, 'top_left', 'addImage')
    checkParameter(scale, {message: "if its an array, it shall contain two elements" ,function: (s) => Array.isArray(s) == (s.length == 2)}, 'scale', 'addImage')
    checkParameter(opacity, isBetweenOneAndZero, 'opacity', 'addImage')
    checkParameter(contrast, isNonNegative, 'contrast', 'addImage')
    checkParameter(saturate, isNonNegative, 'saturate', 'addImage')
    checkParameter(z + 2, isPositive, 'z', 'addImage')
    if (bg_color) checkParameter(bg_color, isHexColor, 'bg_color', 'addImage')
    checkParameter(bg_alpha, isBetweenOneAndZero, 'bg_alpha', 'addImage')
    if (entry) checkParameter(entry, isAnimationClass, 'entry', 'addImage')

    // get the dom document
    const document = cy.state('document')
    // create image box to contain the image
    const img = document.createElement('img')

    img.classList.add(imageClass)
    if (entry) {
        addStyles()
        img.classList.add(getAnimationClass(entry))
    }

    setImageSource(img, source)

    // These variables may be used if an image is positioned relative to an element
    var scaleString
    var moveX
    var moveY
    // Set the scale of the image
    if (typeof scale == 'object') {     // If the scale is an array, apply the scale to the width and height independently
        // Since the image is scale from the center, we must move the image to its original position
        moveX = ((scale[0] - 1) / (2 * scale[0])) * 100
        moveY = ((scale[1] - 1) / (2 * scale[1])) * 100
        scaleString = "scale(" + scale[0] + ', '+ scale[1] + ")"
        img.style.transform = scaleString + " translate3d(" + moveX + "%, " + moveY + "%, 0)"
    } else {                
        // Since the image is scale from the center, we must move the image to its original position            // If the scale is an int, apply the scale to both the width and height
        moveX = ((scale - 1) / (2 * scale)) * 100 
        moveY = ((scale - 1) / (2 * scale)) * 100 
        scaleString = "scale(" + scale + ")"     
        img.style.transform = scaleString + " translate3d(" + moveX + "%, " + moveY + "%, 0)"
    }

    // Check if the image needs to be resized
    if (!resize) {
        img.style.objectFit = 'none'
    }
    // Crop a part of the image
    img.style.objectPosition = -top_left[0] + 'px ' + -top_left[1] + 'px'
    // If there is a specified width, set the image width to that width
    if (width) img.width = width
    // If there is a specified height, set the image height to that height
    if (height) img.height = height

    // Set the position of the image to fixed or absolute
    if (!absolute) {
        img.style.position = 'fixed'
    } else {
        img.style.position = 'absolute'
    }

    if (subject) {          // Place the image relative to an element on screen
        // Mapping each position to certain values, used for positioning the image
        const positionMapping = new Map([
            ['above', [0, 0.5, 1, 0.5]],
            ['below', [1, 0.5, 0, 0.5]],
            ['left', [0.5, 0, 0.5, 1]],
            ['right', [0.5, 1, 0.5, 0]],
            ['on_top', [0.5, 0.5, 0.5, 0.5]],
        ]);

        // Get the top left of the element
        var image_x = getOffset(subject[0]).left
        var image_y = getOffset(subject[0]).top
        // We use the element selector to find the width and height of the element
        const element_width = subject[0].offsetWidth
        const element_height = subject[0].offsetHeight

        const positions = ['on_top', 'above', 'below', 'left', 'right']     // List of positions
        if (!positions.includes(pos)) pos = 'on_top'            // If the position is not in the list, set the position to 'on_top'
        img.style.top = intToPx(image_y + (positionMapping.get(pos)[0] * element_height) + y)   // Set y coordinate of image
        img.style.left = intToPx(image_x + (positionMapping.get(pos)[1] * element_width) + x)   // Set x coordinate of image
        const translateY = -100 * positionMapping.get(pos)[2]       // How much the image should move up or down
        const translateX = -100 * positionMapping.get(pos)[3]       // How much the image should move left or right
        // Move the image up/down and left/right
        img.style.transform = scaleString + " translate3d(" + (translateX + moveX) + "%, " + (translateY + moveY) + "%, 0)"
    } else {                // Place the image at an exact position
        // Set the top left coordinates of the image
        img.style.top = intToPx(y)
        img.style.left = intToPx(x)
    }

    setImageZ(img, z)

    // Set the background color and background opacity of the image
    img.style.backgroundColor = bg_color in COLOR_DICT ? COLOR_DICT[bg_color] + alphaToHtml(bg_alpha) : bg_color + alphaToHtml(bg_alpha)
    // Set the opacity of the image
    img.style.opacity = opacity
    // Set the rotation of the image
    img.style.rotate = rotate + "deg"
    // Set the filters of the image
    // We can still add: blur, brightness, drop-shadow, grayscale, hue-rotate, invert, sepia. See https://developer.mozilla.org/en-US/docs/Web/CSS/filter-function
    img.style.filter = "contrast(" + contrast + ") saturate(" + saturate + ")"

    // Tell the element to stay on top of other video elements
    if (stayOnTop) img.setAttribute('data-stay-on-top', "")
    
    // Generate an id for this element and append the image to the screen
    img.id = Math.random().toString(36).slice(2, 7)
    //document.body.appendChild(img)
    addToBody(document, img)

    // Notify Utility for the potential stayOnTop enjoyers
    getNextZIndex(z)

    // Add wait to ensure animation can finish playing before continuing
    if (entry) cy.wait(1000, {log: false})

    // Automatic wait and removal
    if (wait) {
        cy.get('[id=\'' + img.id + '\']', {log: false}).wait(wait).remove() // We do want this one to be logged, because it's supposed to be a normal wait.
        return cy.wrap(null, {log: false})
    }

    // Return the created image
    return cy.get("#" + img.id, {log: false})
}

Cypress.Commands.add('addImage', {prevSubject : 'optional'}, addImage)


/**
 * Sets the source of an image. Either through a URL or through a local filepath.
 * @param {object} img - The image to set the source of.
 * @param {string} source - The source to get the image data from.
 */
function setImageSource(img, source) {
    if (source.includes('https://') || source.includes('http://')) {
        // If the source is a URL, read the URL
        img.src = source
    } else {
        // If the source is a local file, read the local file
        cy.fixture(source).then((logo) => {
            img.src = "data:image/png;base64,"+logo
          })
    }
}


/**
 * Sets the appropriate z-index of the image.
 * @param {object} img - The image.
 * @param {number} z - The z-index.
 */
function setImageZ(img, z) {
    // Check if custom z index is valid, otherwise get default next z-index
    let zIndex = z
    const nextZ = getNextZIndex(z)    // Still call getNextZIndex in a slightly roundabout way to also trigger keepOnTop call in utility
    if (z === -1) zIndex = nextZ
    img.style.zIndex = zIndex
}