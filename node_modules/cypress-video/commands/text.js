
import {intToPx, alphaToHtml, viewportWidth, viewportHeight, getNextZIndex, addToBody, getOffset,isElementUnderFixed} from '../utility.js'
import {COLOR_DICT, addStyles} from './style.js'
import { checkParameter, isHexColor, isAnimationClass, isBetweenOneAndZero, isPositive } from '../errors.js'

export const textClass = 'cypress-video-text'

/**
 * Add text at the given position
 * @param {Cypress.Chainable} subject - Supplied by Cypress. Not needed to use this parameter.
 * @param {string} source - The text string to be displayed.
 * @param {string} [pos] - The position of the image relative to an element. Accepted values are: on_top, above, below, left and right.
 * @param {int} [size] - The font size to be used to display the text.
 * @param {int} [width] - The screen width across which the text is displayed. -1 means 70% of the screen gets used.
 * @param {int} [x] - The x-coordinate that will be the center of the text. -1 means the text gets centered.
 * @param {int} [y] - The y-coordinate where the text should start. -1 means the text is displayed in the bottom 1/5th of the screen.
 * @param {int} [z] - The z-index of the text.
 * @param {string} [font] - Font to display the text with. Should be one of Arial, Verdana, Tahoma, Trebuchet MS, Times New Roman, Georgia, Garamond, Courier New or Brush Script MT
 * @param {string} [color] - The color of the text, using HTML hexadecimal colour codes (eg. #FFD200).
 * @param {string} [bg_color] - The color of the background area, using HTML hexadecimal colour codes (eg. #FFD200).
 * @param {float} [bg_alpha] - The opacity of the background area.
 * @param {boolean} [bold] - Whether the text is bold.
 * @param {boolean} [italic] - Whether the text is italic.
 * @param {boolean} [underline] - Whether the text is underlined.
 * @param {boolean} [absolute] - Whether the rectangle is fixed to the viewport or absolutely positioned on the webpage.
 * @param {float} [rotate] - How much the text should be rotated clockwise.
 * @param {string} [entry] - The entry animation the text should have.
 * @param {boolean} [stayOnTop] - Whether or not the text should stay on top of every other element, z-index wise.
 * @param {number} [wait] - The amount of time to automatically wait after adding the text and then removing it. Note that multitasking during this wait is **not** possible.
 * @returns {Cypress.Chainable} The cypress-wrapped text element that was added.
 */

function addText(subject, text="", {
    pos='below',
    size=20,
    width=null,
    x=null,
    y=null,
    z=-1,
    font='Arial',
    color='#FFFFFF',
    bg_color='#000000',
    bg_alpha=0.9,
    bold=false,
    italic=false,
    underline=false,
    absolute=false,
    rotate=0,
    entry=null,
    stayOnTop=false,
    wait = null
}={}) {
    if (Cypress.env("CY_VIDEO_MODE") != true) {
        const document = cy.state('document')
        return cy.wrap(document.body, {log: false})
    }

    Cypress.log({displayName: "addText"})

    //check parameters
    checkParameter(size, isPositive, 'size', 'addText')
    checkParameter(font, {message: "is a string", function: (f) => typeof f == 'string'}, 'font', 'addText')
    checkParameter(color, isHexColor, 'color', 'addText')
    checkParameter(z + 2, isPositive, 'z', 'addText')
    checkParameter(bg_alpha, isBetweenOneAndZero, 'bg_alpha', 'addText')
    if (entry) checkParameter(entry, isAnimationClass, 'entry', 'addText')

    // get the dom document
    const document = cy.state('document')

    // create div to contain the text
    const textbox = document.createElement('div')
    textbox.classList.add(textClass)

    // set text
    textbox.innerHTML = text

    // generate an id for our div
    textbox.id = Math.random().toString(36).slice(2, 7)

    if (Cypress.env('CY_VIDEO_MODE') != true) {
        document.body.appendChild(textbox)
        return cy.get("#" + textbox.id)
    }

    // set text style attributes
    if (entry) {
        addStyles()
        textbox.classList.add('cypress-video-creator-' + entry)
    }
    textbox.style.fontSize = intToPx(size)
    textbox.style.textAlign = 'center'
    textbox.style.fontFamily = font
    textbox.style.color = color in COLOR_DICT ? COLOR_DICT[color] : color
    textbox.style.backgroundColor = bg_color in COLOR_DICT ? COLOR_DICT[bg_color] + alphaToHtml(bg_alpha) : bg_color + alphaToHtml(bg_alpha)

    if (bold) textbox.style.fontWeight = 'bold';
    if (italic) textbox.style.fontStyle = 'italic';
    if (underline) textbox.style.textDecoration = 'underline';

    // make sure the text will wrap correctly
    textbox.style.overflowWrap = 'break-word';

    if (subject) {
        absolute = positionSubject(document, subject, textbox, absolute, pos, x, y, width)
    } else {
        // calculate default position
        if (x === null) x = viewportWidth() / 2
        if (y === null) y = viewportHeight() / 5 * 4
        width = width || viewportWidth() / 10 * 7
        // set the position through css
        textbox.style.top = intToPx(y)
        textbox.style.left = intToPx(x-width/2)
        textbox.style.width = intToPx(width)
    }

    // set the css position attribute to the specified mode
    if (absolute) {
        textbox.style.position = "absolute"
    } else {
        textbox.style.position = "fixed"
    }

    // set zIndex to a high value to ensure text is put in front of website
    let zIndex = z  // Or a custom z index
    const next = getNextZIndex(z)    // Still call getNextZIndex in a slightly roundabout way to also trigger keepOnTop call in utility
    if (z === -1) zIndex = next
    textbox.style.zIndex = zIndex

    // Tell the element to stay on top of other video elements
    if (stayOnTop) textbox.setAttribute('data-stay-on-top', "")

    // not sure what these are for / are needed
    textbox.style.border = intToPx(2)
    textbox.style.pointerEvents = 'none'

    // display as a css block
    textbox.style.display = 'block'

    // Give a rotation relative to the center of the element
    textbox.style.rotate = rotate + "deg"

    // add the created div to the website
    // document.body.appendChild(textbox)
    addToBody(document, textbox)

    // Notify Utility for the potential stayOnTop enjoyers
    getNextZIndex(z)

    // Add wait to ensure animation can finish playing before continuing
    if (entry) cy.wait(1000, {log: false})

    // Automatic wait and removal
    if (wait) {
        cy.get('[id=\'' + textbox.id + '\']', {log: false}).wait(wait).remove() // We do want this one to be logged, because it's supposed to be a normal wait.
        return cy.wrap(null, {log: false})
    }
    

    // return the created div
    return cy.get("#" + textbox.id, {log: false})
}

Cypress.Commands.add('addText', {prevSubject : 'optional'}, addText)


function positionSubject(document, subject, textbox, absolute, pos, x, y, width) {
    // Mapping each position to certain values, used for positioning the textbox
    const positionMap = new Map([
        ['on_top', [0.5, 0.5, 0.5, 0.5]],
        ['above', [0, 0.5, 1, 0.5]],
        ['below', [1, 0.5, 0, 0.5]],
        ['left', [0.5, 0, 0.5, 1]],
        ['right', [0.5, 1, 0.5, 0]],
    ]);
    // Get the top left of the element
    var element_x = getOffset(subject[0]).left
    var element_y = getOffset(subject[0]).top
    
    // Check if a fixed element is being textHighlighted
    const element = (subject.selector ? document.querySelectorAll(subject.selector) : [subject[0]])[0]
    if (!isElementUnderFixed(document, element)) absolute = true

    // We use the element selector to find the width and height of the element
    const element_width = subject[0].offsetWidth
    const element_height = subject[0].offsetHeight

    const positions = ['on_top', 'above', 'below', 'left', 'right']     // List of positions
    if (!positions.includes(pos)) pos = 'below'            // If the position is not in the list, set the position to 'on_top'
    textbox.style.top = intToPx(element_y + (positionMap.get(pos)[0] * element_height) + y)   // Set y coordinate of textbox
    textbox.style.left = intToPx(element_x + (positionMap.get(pos)[1] * element_width) + x)   // Set x coordinate of textbox
    textbox.style.width = intToPx(Math.max(200, element_width))        // Does not change per position
    const translateY = -100 * positionMap.get(pos)[2]       // How much the textbox should move up or down
    const translateX = -100 * positionMap.get(pos)[3]       // How much the textbox should move left or right

    if (width != null) textbox.style.width = intToPx(width)
    // Move the image up/down and left/right
    textbox.style.transform = " translate3d(" + translateX + "%, " + translateY + "%, 0)"

    return absolute
}