const {
    execSync
} = require('child_process')
const {
    setAudioStartTime
} = require('./audioPost.js');
const fs = require('fs');
const sp = require('synchronized-promise')
const ffmpeg = require('ffmpeg-downloader');

const { getVideoDurationInSeconds } = require('get-video-duration')

var startTime
var endTime
var endSpecTime
var first = true
var videoShouldCut = false

/**
 * Trims away the beginning of the video until the time the `cy.startVideo()` command was called.
 * @param {string} video - The video file name.
 * @param {number} seconds - The amount of seconds to cut off the front of the video
 */
function cutVideo(video, seconds) {

    // Get ffmpeg path to use in ffmpeg commands
    const exe = ffmpeg.path;

    // Temporary file to store the cut video
    const output = video.substring(0, video.lastIndexOf("\\")) + "\\cut.mp4"

    // Build the command that ffmpeg will run. It will look something like this:
    // $ ffmpeg -ss (time)s -i "input.mp4" "output.mp4"
    // Cuts off the first var(seconds) seconds of the video
    const cmd = '"' + exe
        + '" -ss ' + seconds
        + ' -i "'
        + video + '"'
        + ' "' + output + '"';

    // Execute the ffmpeg command
    execSync(cmd, (err, stdout, stderr) => {
        if (err) {
            console.error(`exec error: ${err}`);
        }
    });

    // Replace the original .mp4 file with the new .mp4 file
    fs.renameSync(output, video)
}

/**
 * Registers the time of the start of the video. Used by `cy.startVideo()`.
 * @param time - The current datetime.
 */
const getVideoTime = ({time}) => {
    // This task is called twice, we only want the first instance
    if (first) {
        endTime = time              // Track the end time
        setAudioStartTime(time)     // Set start of the audio playing
        first = false               // Set first to false so end time is not overwritten
        videoShouldCut = true       // This signals that the next video should be cut
    }
    return null
}

/**
 * Registers the time of the end of the video. This can't be done in the afterSpec event because it's called a variable time after the actual end of the spec :dread:
 * @param {number} time - The current datetime.
 */
const getEndSpecTime = ({time}) => {
    endSpecTime = time              // Track the end spec time
    return null
}

const videoBeforeSpec = () => {startTime = Date.now();}

const videoAfterSpec = (spec, results) => {
    // Get the video duration of the original video
    var originalVideoDuration
    let syncfunc = sp(getVideoDurationInSeconds)
    originalVideoDuration = syncfunc(results.video)

    if (videoShouldCut) {      // If the end time is defined, a part of the video needs to be cut off
        // Get the desired video length using the two measured timestamps
        if(typeof endSpecTime != 'number' || typeof endTime != 'number'){
            throw new Error("Video Timing Error: The endtime of the video could not be determined \n," +
             "please make sure the \'endVideo\' command was run at the end of the video")
        }
        const desiredVideoLength = (endSpecTime - endTime) / 1000
        // Determine the time that should be cut off
        const hideTime = originalVideoDuration - desiredVideoLength
        cutVideo(results.video, hideTime)       // Cut the video
        first = true                // Reset first variable so end time of next video can be recorded
        videoShouldCut = false      // Reset video should could variable so the next video is not automatically cut
}}

module.exports = {
    getVideoTime: getVideoTime,
    getEndSpecTime: getEndSpecTime,
    videoBeforeSpec: videoBeforeSpec,
    videoAfterSpec: videoAfterSpec
}
